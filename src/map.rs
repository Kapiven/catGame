use raylib::prelude::*;

pub const MAP_W: usize = 16;
pub const MAP_H: usize = 16;

// 0 = vacÃ­o, 1..n = tipos de pared
pub const MAP1: [[i32; MAP_W]; MAP_H] = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1],
    [1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,1],
    [1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1],
    [1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],
    [1,0,1,0,1,0,1,1,1,0,1,1,1,1,0,1],
    [1,0,1,0,0,0,1,0,0,0,0,0,0,1,0,1],
    [1,0,1,1,1,0,1,0,1,1,1,1,0,1,0,1],
    [1,0,0,0,1,0,1,0,0,0,0,1,0,0,0,1],
    [1,1,1,0,1,0,1,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,1],
    [1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1],
    [1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1],
    [1,0,1,1,1,1,0,1,1,1,0,1,1,1,0,9],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];

pub const MAP2: [[i32; MAP_W]; MAP_H] =[
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,1],
    [1,0,1,0,1,1,1,0,1,1,1,0,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1],
    [1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1],
    [1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1],
    [1,0,1,1,0,1,0,1,1,1,0,1,0,1,0,1],
    [1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1],
    [1,0,1,0,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1],
    [1,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1],
    [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
    [1,0,1,1,0,1,1,1,1,0,1,1,1,1,1,1],
    [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,9],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];

pub fn tile_color(tile: i32) -> Color {
    match tile {
        1 => Color::GRAY,
        9 => Color::GOLDENROD,
        _ => Color::WHITE,
    }
}

pub fn is_walkable(map: &[[i32; MAP_W]; MAP_H], x: f32, y: f32) -> bool {
    if x < 0.0 || y < 0.0 { return false; }
    let gx = x as i32;
    let gy = y as i32;
    if gx < 0 || gy < 0 || gx >= MAP_W as i32 || gy >= MAP_H as i32 {
        return false;
    }
    map[gy as usize][gx as usize] == 0
}
